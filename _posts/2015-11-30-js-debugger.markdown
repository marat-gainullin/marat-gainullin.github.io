---
layout: post
title:  "Отладка JavaScript в NetBeans и Platypus.js"
date:   2015-11-30 10:14:07
disqus: "dbg-nb-platypus.js"
categories: javascript platypus
---

JavaScript завоевывает все больше места на бэкенде. Это очень хорошо, т.к. JavaScript - лучший язык для 
реализации бизнес логики :-).

В предыдущих статьях я рассматривал вопросы и проблемы прикладной бизнес логики и ORM-ов, а 
теперь очень хочется осветить вопросы, связанные с отладкой JavaScript кода.

На клиенте JavaScript отлаживается, что называется "со страшной силой". Существуют различные способы и инструменты.
Чего только стоит отладка в браузерах: Crome Developer Tools, FireFox Web Console, IE 11-12. Хотя там тоже не без
проблем. IE, например не поддерживает Source Maps, отладчик в FF вообще работает или не работает "под настроение".
Кроме того, существуют совсем изуверские средства, такие как NetBeans Connector, представляющий собой браузерный плагин,
который отправляет отладочную информацию в NetBeans, для того, чтобы разработчик смог отлаживать код в привычных для себя
документых/закладках/окнах.

А вот на бекэнде, средства отладки не так сильно развиты. Для Node.js существуют Node.js Tools for Visual Studio и, наверное, еще какие-то инструменты.
Для Nashorn, а значит и для [Platypus.js](http://platypus-platform.org/) есть Askari, NetBeans и Intellij IDEA со своим набором отладочных инструментов.

И вот здесь начинается самое интересное. "Nashorn is still under development" говорят разработчики Oracle.
Что вселяет надежду на лучшее. С другой стророны, пока что со средствами отладки Nashorn-а имеются проблемы.

Для того, чтобы хорошо понять их суть, надо взглянуть на внутренние механизмы, используемые при отладке скриптов,
работающих в Nashorn. Анализ исходников Askari, Intellij IDEA и NetBeans (в части отладки скрипта) дает четкое представление
о том как организована отладка в этих инструментах.

Все они пользуются JPDA отладчиком, поставляемым с JDK (tools.jar и пр.).
Что само по себе очень хорошо. Не надо изобретать свой собственный протокол, как в случае с V8, да и JPDA отладчик построен по гибкой архитектуре что дает возможность встраивать в него какие то новые вещи.

Как известно, Nashorn является компилятором JavaScript-а в байт-код JVM.
Он динамически генерирует классы с префиксом имен "jdk.nashorn.internal.scripts.Script$".
В получающемся байт-коде присутствуют служебные методы ":getMap" и ":createProgramFunction".

Особенность JavaScript-а заключается в том, что это функциональный язык программирования, а значит все куски кода,
т.е. функции должны где то находится и быть перечислены как элементы данных.

Так вот, метод ":getMap", например, служит для получения списка всех свойств JavaScript объекта, будь он scope-ом или просто объектом.
Естественно, в этот список попадают и функции. Вот этим обстоятельством и пользуются вышеперечисленные отладчики. 

Они устанавливают служебную точку останова на вход в метод ":getMap" и после её срабатывания производят свои "магические" 
манипуляции а потом запускают программу дальше работать как ни в чем не бывало.

Но беда в том, что такие служебные точки останова можно устанавливать только в контексте определенного класса, а для этого необходимо знать его имя.
Т.к. классы генерируются динамически и хуже того, благодаря оптимистической системе предсказания типов по нескольку раз, имена классов заранее
не известны. К счастью, JDPA предоставляет механизмы слежения за составом классов в отлаживаемой программе.
Которые состоят в том, что можно установить служебную точку останова на загрузку нового класса.
Отладчики пользуются и этим механизмом чтобы использование первой служебной точки останова имело смысл.

Итак, предположим, что эти точки останова работают как положено и у отладчиков получается корректно обрабатывать все вызовы ":getMap".
Что они делают во время этой обработки? Правильно, устанавливают уже не служебные, а настоящие точки останова
в код соответствующих динамически сгенерированных классов. После чего, служебная точка останова на вход в метод ":getMap" снимается.
Вроде бы цельная концепция и все должно работать.

Но оно не работает!

Каждый, кто сталкиваля с отладкой Nashorn JavaScript в NetBeans иногда замечал такую картину:

![netbeans js debugger](/assets/unexpected-js-breakpoint.png)

Налицо сработавшая точка останова, которую пользователь не устанавливал!

Это происходит потому, что "служебные" точки останова в JPDA не существуют. Служебными их делает особая обработка/настройка
соответствующих сущностей в NetBeans Debugger UI. Они там создаются как "скрытые".
Они не показываются в списке точек останова, на полях в документах и т.д. Но почему то, и самое противное, что только иногда,
пользователь видит как они срабатывают. И в этом случае пользователь вынужден вручную запускать продолжение непонятно почему остановившейся программы!

У вышеописанного подхода к эксплуатации генерируемого Nashorn-ом байт кода есть ещё один серьезный недостаток.
По крайней мере в NetBeans он проявляется достаточно явно. Т.к. благодаря оптимистической системе предсказания типов, один и тот же код
Nashorn-у приходится (если не повезло с предсказаниями) компилировать в байт-код по нескольку раз, в отлаживаемой
программе появляются несколько "теней" одного и того же класса. Понятно, что для JVM это просто какие то новые классы.
Уже упомянутый префикс их имен, кстати, снабжается суффиксом "Recompilation".

Так вот, эти отладчики просто игнорируют новые версии байт кода!
В результате, мы получаем точки останова, которые останавливают программу эпизодически "под настроение" а со временем перестают работать вовсе.

Кроме того, эксплуатация информации о загружаемых классах дает интересный побочный эффект.
Легко можно допустить ошибку в проектировании отладчика и сделать слежение только за вновь загружаемыми классами.
Что, кстати, в NetBeans и сделано. А как же классы уже загруженные на момент присоедининия отладчика?
В случае присоедининия к уже работающему серверу со скриптами ничего из того что хоть как то работало в отладчике NetBeans вообще перестаёт работать!
Конечно, можно сказать, что NetBeans не умеет присоединяться к JavaScript/Nashorn программам, а умеет только запускать их
и таким образом, его отладчик застрахован от того чтобы "просмотреть" уже загруженные классы.

Но тем хуже! Вся архитектура JPDA, сама по себе обладающая невероятной мощью, используется только на половину!

Но это ещё не все беды, свалившиеся на голову наивных отладчиков. Метод ":getMap" по мере оптимизации уже работающей программы перестаёт
включаться в генерируемый Nashorn-ом байт-код. Естественно, это выбивает почву из под ног отладчика.

Кроме того, Nashorn настолько крут, что генерирует такой байт-код, который иногда даже не исполняется!
Но это не потому, что он превращается в "dead code", а потому, что он очень быстро разогревается и превращается в "Hot method"
и благополучно перекомпилируется JIT компилятором JVM в двоичный код, который вовсе не поддается отладке по JPDA.

Кстати, JIT компилятор можно отключить ключом "-Xint" в командной строке отлаживаемой программы.

Разработчики [Platypus.js](http://platypus-platform.org/) не стали мириться со сложившейся ситуацией и переписали JavaScript Breakpoints Manager NetBeans-а в своем дизайнере с учетом вышеизложенных проблем и недостатков других отладчиков.
К счастью, NetBeans RCP позволяет взять и заменить кусок отладчика на свой собственный.

Поэтому в [Platypus.js](http://platypus-platform.org/) IDE точки останова работают всегда, независимо от того, когда отладчик присоединилcя к серверу,
нет неожиданных остановок программы в местах где нет пользовательских точек останова и точки останова работают независимо от
продолжительности сеанса отладки.

К сожалению, пока не удаётся повлиять на возможность отладки JIT скомпилированных фрагментов кода, кроме как отключить JIT компилятор.

У NetBeans отладчика ещё есть проблемы с вычислением выражений. И ими разработчики [Platypus.js](http://platypus-platform.org/) ещё займутся :-)
