---
layout: post
title:  "Прикладной JavaScript и ORM-ы."
date:   2015-09-16 10:37:27
disqus: "orm.js"
categories: javascript platypus
---
Вместе с бурным и почти неуправляемым развитием скриптовых движков, фреймворков и библиотек
на первый план начала выходить проблема отделения прикладной логики от технологий,
применяемых в разработке.

Эта проблема хорошо решается в JavaEE.
JavaEE предоставляет разработчику удобный механизм аннотаций.

Например, для того, чтобы сделать EJB, нужно всего лишь создать класс, содержащий прикладную логику и снабдить его аннотацией @ejb.

Для того, чтобы управлять жизненным циклом такого серверного модуля, нужны аннотации @statefull и  @stateless.

Таким образом, получается что есть некий модуль принадлежащий вашей программе, а то как его обрабатывает контейнер,
указывается в элементах программы, которые вовсе не являются частью ее кода.
Также для разграничения прав доступа, используется аннотация @rolesAllowed и т.п.

В Node.js, например, есть асинхронная модель ввода-вывода, но ее механизмы скрыты от скриптового приложения.

В браузерах и в io.js теперь есть еще и библиотека WebWorkers, но разве разработчик скриптового приложения
пользуется в своей программе объектами синхронизации? Нет, не пользуется.

Это еще один пример отделения технолоний от прикладной логики.

Любой ORM служит той же цели, только в части хранения данных.

Давайте рассмотрим, что нам предлагают сделать со своей программой различные JavaScript библиотеки.

Библиотека для binding-а, Knockout.js:

{% highlight javascript %}
function TaskListViewModel() {
  // Data
  var self = this;
  self.tasks = ko.observableArray([]);
  self.newTaskText = ko.observable();
  self.incompleteTasks = ko.computed(function () {
    return ko.utils.arrayFilter(
        self.tasks(),
        function (task) {
          return !task.isDone()
        });
    });
}
ko.applyBindings(new TaskListViewModel());
{% endhighlight %}

Такой код изобилует логикой, специфичной для библиотеки Knockout.js.
Посмотрите хотя бы на ko.computed()

ORM для Node.js BookShelf.js:

```javascript
var Customer = bookshelf.Model.extend({
    initialize: function () {
        this.on('saving', this.validateSave);
    },
    validateSave: function () {
        return checkit(rules).run(this.attributes);
    }
});
```

Этот ORM принуждает нас наследовать классы предметной области от библиотечного класса bookshelf.Model!

Библитотека, для работы с событиями backbone.js:

```javascript
var Subject = {};
_.extend(Subject, Backbone.Events);
Subject.on("alert", function (msg) {
    alert("Triggered " + msg);
});
Subject.trigger("alert", "an event");
```

Здесь _.extend инжектирует некоторые свои методы в наш объект и после этого мы можем обрабатывать события, вызванные функцией .trigger()

Предположим, что нам это все не мешает и мы радостно включаем такой код в свою программу.
А что будет с нашей прикладной логикой, если мы захотим отказаться от одной из используемых в приложении библиотек?
Её придется переписывать заново! Полностью!

